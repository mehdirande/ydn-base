<h1 class="classTitle">Class ydn.db.core.Storage</h1>

<p>Wrapper for IndexedDB, WebSQL and web storage API. This provides robust
  active transaction objects. </p>

<table cellspacing="0" class="summaryTable">

  <caption>
    Class Summary
  </caption>
  <thead>
  <tr>
    <th>Constructor Attributes</th>
    <th>Constructor Name and Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="attributes">&nbsp;</td>
    <td class="nameDescription">
      <div class="fixedFont">
        <b><a href="#constructor">ydn.db.con.Storage</a></b>(name, schema, options)
      </div>
      <div class="description">
        Create a connection to suitable storage mechanism and initialize the 
        database with given schema and options.
      </div>
    </td>
  </tr>
  </tbody>
</table>


<table cellspacing="0" class="summaryTable">
  <caption>
    Method Summary
  </caption>
  <thead>
  <tr>
    <th>Method Attributes</th>
    <th>Method Name and Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="attributes">&nbsp;</td>
    <td class="nameDescription">
      <div class="fixedFont">
        <b><a href="#close">close</a></b>()
      </div>
      <div class="description">
        Close the database connection.
      </div>
    </td>
  </tr>
  <tr>
    <td class="attributes">&nbsp;</td>
    <td class="nameDescription">
      <div class="fixedFont">
        <b><a href="#getSchema">getSchema</a></b>()
      </div>
      <div class="description">
        Get schema of this storage.
      </div>
    </td>
  </tr>
  <tr>
    <td class="attributes">&nbsp;</td>
    <td class="nameDescription">
      <div class="fixedFont">
        <b><a href="#setName">setName</a></b>(name)
      </div>
      <div class="description">
        Set database name.
      </div>
    </td>
  </tr>
  <tr>
    <td class="attributes">&nbsp;</td>
    <td class="nameDescription">
      <div class="fixedFont">
        <b><a href="#transaction">transaction</a></b>(transaction_callback,
        store_names,
        mode, completed_event_handler)
      </div>
      <div class="description">
        Perform a database transaction.
      </div>
    </td>
  </tr>
  <tr>
    <td class="attributes">&nbsp;</td>
    <td class="nameDescription">
      <div class="fixedFont">
        <b><a href="#setSchema">type</a></b>(schema)
      </div>
      <div class="description">
        Get storage mechanism type.
      </div>
    </td>
  </tr>
  </tbody>
</table>

<div class="details">
  <a name="constructor"></a>
  <div class="sectionTitle">
    Class Detail
  </div>
  <div class="fixedFont">
    <b>ydn.db.con.Storage</b>(dbname, schema, options)
  </div>
  <div class="description">
    Create a connection to suitable storage mechanism and initialize the
    database. The created storage mechanism depending on preference setting and
    runtime environment. The connection can be create later, by providing
    <code>undefined</code> value to database name. 
    Connection will be created when when the database name is set and perform
    pending database operation.</div>

  <dl class="detailList">
    <dt class="heading">Parameters:</dt>

    <dt><span class="light fixedFont optional">{string=}</span> <b>name</b>
    </dt>
    <dd>Database name.</dd>

    <dt><span
        class="light fixedFont optional">{!ydn.db.DatabaseSchema|!DatabaseSchema=}</span>
      <b>schema</b></dt>

    <dd>Optional database schema JSON format. The default schema is {}. Schema
      is&nbsp;up-gradable by increasing version numeric value.
      If version is not provided, database schema can be changed during the
      life time of the connection. Internally database connection will be 
      recreated depending on the storage mechanism and version.
      <br/>
      Schema defines a list of store schemas. All are optional unless noted.

<pre>schema = {
version: 1,
Stores: [{
    name: 'customer',    // required. object store name or TABLE name
    keyPath: 'email',    // keyPath.
    type: 'TEXT',        // data type of the key.
    autoIncrement: true, // if true, key will be automatically created if
  not provided. If true, data type must be INTEGER.
}, {
    name: 'product',
    keyPath: 'id.sku',
    Indexes: [{
       keyPath: 'origin', // required.
       name: 'name',      // usually omitted. generally same as keyPath.
       unique: true,      // unique constrain
       multiEntry: true   //
    }]
}]
}
      </pre>
      The data type is required for creating Sqlite  TABLE for COLUMN
      definition. The data type is also used in
      input argument check.Possible value of data types are: <code>TEXT</code> (default), <code
          >NUMERIC</code>, <code>INTEGER</code>, <code>DATE</code> and
      <code>ARRAY</code>.
      <br/>
      If <code>keyPath</code> is provided, it is called in-line key, otherwise
      out-of-line key. If out-of-line key is used, key must be separately
      provided unless <code>autoIncrement</code> is set true.
      <code>keyPath</code> is field name of the record object. Nested inner
      field can be defined by javascript doted notation.
      <br/>
      If <code>multiEntry</code> is set true, the value of the index as
      specified by its keyPath can be array and its array elements are indexed
      separately.
    </dd>

    <dt><span class="light fixedFont optional">{!Object=}</span>
      <b>options</b></dt>

    <dd>Additional options.
    </dd>

    <dl class="detailList">
      <dt class="heading">Option keys:</dt>
      <dt><span class="light fixedFont">{!Array.&lt;string&gt;}</span> <b>
        Mechanisms</b></dt>
      <dd>preferential ordering of store mechanisms.</dd>
      <dt><span class="light fixedFont">{number}</span> <b>size</b></dt>
      <dd>estimated database size in bytes(only used in WebSQL).</dd>
      <dt><span class="light fixedFont">{boolean}</span> <b>used_text_store</b></dt>
      <dd>use default key-value text store.</dd>
    </dl>


<pre>options = {
  preference: ["indexeddb", "websql", "localstorage", "sessionstorage", "memory"], // default ordering
  size: 2 * 1024 * 1024, // 2 MB
};
    </pre>
  </dl>
</div>

<div class="sectionTitle">
  Method Detail
</div>

<a name="close"></a>


<div class="fixedFont">
  <span class="light">{!goog.async.Deferred}</span> <b>close</b>()
</div>


<div class="description">
  Close the database connection.
</div>

<hr>

<a name="getSchema"></a>
<div class="fixedFont">
  <span class="light">{!DatabaseSchema}</span>
  <b>getSchema</b> (callback)
</div>
<div class="description">
  Get schema of this storage. This is useful from getting storage from
  main thread to worker thread.
</div>


<dl class="detailList">
  <dt class="heading">Parameters:</dt>
  <dt><span class="light fixedFont">{function(!DatabaseSchema)=}</span> <b>
    callback</b></dt>
  <dd><i>Optional.</i> Extract database schema from the database
    connection. </dd>

  <dt class="heading">Returns:</dt>

  <dd><span
      class="light fixedFont">{!DatabaseSchema}</span>
    Schema used to create and validate the input configuration.
  </dd>
</dl>

<hr>


<a name="setName"></a>
<div class="fixedFont">
  <span class="light">{string}</span> <b>setName</b>(name)
</div>
<div class="description">
  Set database name. This will initialize the database connection.
</div>
<dl class="detailList">
  <dt class="heading">Parameters:</dt>
  <dt><span class="light fixedFont">{string}</span> <b>name</b></dt>
  <dd>name of database.</dd>
</dl>
<dl class="detailList">
  <dt class="heading">Throws:</dt>
  <dt><span class="light fixedFont">{Error}</span></dt>
  <dd>If database is already initialized.</dd>
</dl>
<hr>

<a name="transaction"></a>
<div class="fixedFont">
  <b>transaction</b>(transaction_callback, store_names,
  mode, completed_event_handler)
</div>
<div class="description">
  Acquire transaction object from the database connection and return immediately.
</div>
<dl class="detailList">
  <dt class="heading">Parameters:</dt>
  <dt><span class="light fixedFont">{!function(tx)}</span> <b>transaction_callback</b>
  </dt>
  <dd>Transaction in callback function. The callback is invoke is with native
    transaction object <code>IDBTransaction</code>,
    <code>SQLTransaction</code>, or <code>localStorage</code> depending on
    runtime environment.
    Use duck typing to check the require type. Transaction will automatically
    commit if not use
    actively.
  </dd>
  <dt><span class="light fixedFont">{Array.}</span> <b>store_names</b></dt>
  <dd>List of store name. If empty list, all stores are open.</dd>
  <dt><span class="light fixedFont">{string}</span> <b>mode</b></dt>
  <dd>Transaction mode: <code>readonly</code> (default),
    <code>readwrite</code> or <code>versionchange</code>.
  </dd>
  <dt><span
      class="light fixedFont">{function(string: type, *: event)}</span> <b>completed_event_handler</b>
  </dt>
  <dd>Handle event for transaction <code>completed</code>, <code>error</code> or
    <code>abort</code> event type.
    If provided, handler will be called once and only once immediately after the
    transacting become
    inactive.
  </dd>
  <dt><span class="light fixedFont">{...}</span> <b>opt_var_args</b></dt>
  <dd>Optional variable arguments pass back to <code>transaction_callback</code>
    prepending argument <code>tx</code></dd>
  <br>
<pre>db.transaction(function transaction_callback (tx) {
  if (tx.objectStore) {
    request = tx.objectStore('player').openCursor()
    request.onsuccess = function(event) {
      console.log('IndexedDB got ' + JSON.stringify(event.target.result.value))
    }
  } else if (tx.executeSql) {
    tx.executeSql('SELECT * FROM player', [], function(tr, results) {
      console.log('WebSql got ' + JSON.stringify(results.rows.item(0)));
    })
  } else { // localStorage or memory store. In any case, it has getItem, setItem, etc
    var v = tx.getItem('_database_tr_test2-player-1')
    console.log('localStorage got ' + v);
  }
}, ['player'], 'readwrite')</pre>


</dl>
